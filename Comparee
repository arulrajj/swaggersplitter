#!/usr/bin/env python3
"""
bt_bill_compare_v3.py

Improved BT bill comparator (single file). Fixes:
 - ignores right-hand sidebar numbers (company reg no)
 - attaches each line item to its section (no cross-section summing)
 - avoids interpreting dates/years as amounts
 - ignores heading-only rows like 'These figures exclude VAT' without amounts
 - compares items only when same section+description found in both PDFs

Usage:
    python bt_bill_compare_v3.py --dirA ./a --dirB ./b --out ./reports
"""

import os
import re
import io
import sys
import argparse
import logging
import html
from decimal import Decimal, InvalidOperation
from collections import defaultdict, namedtuple
from datetime import datetime
from difflib import SequenceMatcher

# optional fuzzy
try:
    from rapidfuzz import fuzz
    HAVE_RAPIDFUZZ = True
except Exception:
    HAVE_RAPIDFUZZ = False

# pdf libs
try:
    import fitz
    from PIL import Image
    import pytesseract
    from pdf2image import convert_from_path
    from jinja2 import Template
except Exception as e:
    print("Missing Python deps. pip install pymupdf pillow pytesseract pdf2image jinja2")
    raise

logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger("bt-bill-compare-v3")

# patterns
AMOUNT_PATTERN = re.compile(r"-?\£?\s*([0-9]{1,3}(?:[,\.][0-9]{3})*(?:[\.][0-9]{1,2})?|[0-9]+(?:\.[0-9]{1,2})?)")
ACCOUNT_RE = re.compile(r"(?:Account(?: number)?|Account No|A/C No|Customer No)[\:\s]*([A-Z0-9\-]{4,})", re.I)
UK_POSTCODE_RE = re.compile(r"[A-Z]{1,2}\d{1,2}[A-Z]?\s*\d[A-Z]{2}", re.I)
YEAR_RE = re.compile(r"\b(19|20)\d{2}\b")
DATE_RE = re.compile(r"\b(?:\d{1,2}\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)|\d{1,2}/\d{1,2}/\d{2,4})\b", re.I)

ParsedBill = namedtuple("ParsedBill", ["file", "account", "address", "items", "vat_summary", "subtotal", "vat", "total", "raw_rows"])


def norm_amount(s):
    if s is None:
        return None
    s = str(s).strip().replace("£", "").replace(",", "")
    try:
        return Decimal(s).quantize(Decimal("0.01"))
    except Exception:
        try:
            return Decimal(float(s)).quantize(Decimal("0.01"))
        except Exception:
            return None


def similar(a, b):
    if not a or not b:
        return 0
    if HAVE_RAPIDFUZZ:
        return fuzz.token_sort_ratio(a, b)
    else:
        return int(SequenceMatcher(None, a, b).ratio() * 100)


# ----- layout extraction (PyMuPDF spans) -----

def extract_spans(pdf_path, use_ocr_if_empty=True, ocr_dpi=200):
    pages_spans = []
    try:
        doc = fitz.open(pdf_path)
    except Exception as e:
        logger.exception("open pdf failed: %s", e)
        return []

    for pnum in range(len(doc)):
        page = doc[pnum]
        page_dict = page.get_text("dict")
        spans = []
        for block in page_dict.get("blocks", []):
            if block.get("type") != 0:
                continue
            for line in block.get("lines", []):
                for span in line.get("spans", []):
                    text = span.get("text", "").strip()
                    if text:
                        x0, y0, x1, y1 = span.get("bbox")
                        spans.append({"text": text, "x0": x0, "y0": y0, "x1": x1, "y1": y1, "size": span.get("size")})
        # if spans too few and OCR allowed -> OCR page
        if use_ocr_if_empty and len(spans) < 6:
            try:
                pix = page.get_pixmap(dpi=ocr_dpi)
                img = Image.open(io.BytesIO(pix.tobytes("png"))).convert("RGB")
                ocr_text = pytesseract.image_to_string(img)
                # crude: place OCR lines at bottom area
                y = page.rect.y1 - 20
                for i, ln in enumerate([l for l in ocr_text.splitlines() if l.strip()]):
                    spans.append({"text": ln.strip(), "x0": 0, "y0": y + i*9, "x1": page.rect.x1, "y1": y + i*9 + 8, "size": 10})
            except Exception:
                pass
        pages_spans.append({"width": page.rect.x1, "spans": spans})
    doc.close()
    return pages_spans


def group_rows(spans, y_tol=3):
    """Group spans into rows by y coordinate and sort each row by x0"""
    if not spans:
        return []
    s_sorted = sorted(spans, key=lambda s: (round(s["y0"]), s["x0"]))
    rows = []
    cur_y = None
    cur = []
    for s in s_sorted:
        y = round(s["y0"])
        if cur_y is None:
            cur_y = y
            cur = [s]
        elif abs(y - cur_y) <= y_tol:
            cur.append(s)
        else:
            rows.append(sorted(cur, key=lambda ss: ss["x0"]))
            cur = [s]
            cur_y = y
    if cur:
        rows.append(sorted(cur, key=lambda ss: ss["x0"]))
    # convert to text row with spans
    out = []
    for r in rows:
        text = " ".join([sp["text"] for sp in r])
        out.append({"y": r[0]["y0"], "spans": r, "text": text})
    return out


# ----- heuristics to detect sidebar & main content -----

def detect_sidebar_threshold(page_spans):
    """
    Compute a threshold x coordinate to consider as sidebar region (right-side area).
    Approach: look for cluster of spans at extreme right across page and estimate boundary.
    We'll compute 85th percentile x0 of spans and set threshold as percentile - small offset.
    """
    all_x0 = [s["x0"] for s in page_spans if page_spans]
    if not all_x0:
        return None
    sorted_x0 = sorted(all_x0)
    # 85th percentile
    idx = int(len(sorted_x0) * 0.85)
    p85 = sorted_x0[idx] if idx < len(sorted_x0) else sorted_x0[-1]
    # reasonable offset
    return p85 - 10


# ----- parsing sections, line items, vat, totals -----

SECTION_KEYWORDS = [
    ("regular_charges", ["regular charges", "regular charge", "regular charge s"]),
    ("one_off", ["one-off charges", "one-off charges and credits", "one off charges", "one off charges and credits"]),
    ("discounts", ["discounts"]),
    ("vat_summary", ["vat summary", "your vat summary", "total vat", "vat at"]),
    ("charges_detail", ["your charges in detail", "charges for"]),
    ("overview", ["total for this bill", "total owed on this account", "this bill"])
]

def detect_section(row_text):
    lt = row_text.lower()
    for key, kws in SECTION_KEYWORDS:
        for kw in kws:
            if kw in lt:
                return key
    return None


def split_row_lr(row, page_width, split_pct=0.62):
    """Split row into left and right by x coordinate threshold (percent of width)"""
    split_x = page_width * split_pct
    left_parts = []
    right_parts = []
    for sp in row["spans"]:
        mid = (sp["x0"] + sp["x1"]) / 2.0
        if mid <= split_x:
            left_parts.append((sp["x0"], sp["text"]))
        else:
            right_parts.append((sp["x0"], sp["text"]))
    left = " ".join([t[1] for t in sorted(left_parts)]) if left_parts else ""
    right = " ".join([t[1] for t in sorted(right_parts)]) if right_parts else ""
    return left.strip(), right.strip()


def row_has_amount_in_main(right_text, page_width, sidebar_threshold):
    """
    Decide whether the right_text contains a main-body monetary amount:
    - Must match AMOUNT_PATTERN
    - Must not be a year (e.g., 2026)
    - The span giving the amount must be left of sidebar_threshold (i.e., not in sidebar)
    """
    if not right_text:
        return None
    # prefer finding amount pattern
    m = AMOUNT_PATTERN.search(right_text)
    if not m:
        return None
    token = m.group(1)
    # exclude year-like tokens
    if YEAR_RE.search(token) or DATE_RE.search(right_text):
        return None
    # token normalized
    amt = norm_amount(token)
    return amt


def find_account_and_address(pages_rows):
    """Scan to find account and billing address"""
    account = None
    address_cands = []
    for page in pages_rows:
        for i, row in enumerate(page["rows"]):
            t = row["text"]
            if not account:
                m = ACCOUNT_RE.search(t)
                if m:
                    account = m.group(1).strip()
            if "billing address" in t.lower():
                # take next few rows as address
                addr = []
                for j in range(i+1, min(i+6, len(page["rows"]))):
                    addr.append(page["rows"][j]["text"])
                address_cands.append(" ".join(addr))
            elif UK_POSTCODE_RE.search(t):
                address_cands.append(t)
    address = max(address_cands, key=lambda s: len(s)) if address_cands else None
    return account, address


def parse_pages(pages_spans):
    """
    For each page: compute rows, detect sidebar threshold, then parse rows into sections and items.
    Return:
      pages_rows: list per-page rows
      items: dict keyed by (section, norm_desc) -> {amount, example}
      vat_summary, subtotal, vat, total
    """
    items = {}  # key -> {"amount": Decimal, "example": desc, "page":p}
    pages_rows = []
    vat_summary = {}
    subtotal = vat = total = None

    for p_idx, p in enumerate(pages_spans):
        page_width = p["width"]
        spans = p["spans"]
        if not spans:
            pages_rows.append({"rows": [], "width": page_width, "sidebar_threshold": None})
            continue
        rows = group_rows(spans)
        # detect sidebar threshold based on spans (more robust)
        sidebar_thr = detect_sidebar_threshold(spans)
        pages_rows.append({"rows": rows, "width": page_width, "sidebar_threshold": sidebar_thr})

    # iterate pages again to build items with sections
    for p_idx, page in enumerate(pages_rows):
        rows = page["rows"]
        w = page["width"]
        thr = page["sidebar_threshold"] or (w * 0.85)
        current_section = None
        for row in rows:
            text = row["text"].strip()
            if not text:
                continue
            # detect section header (and change current_section)
            sec = detect_section(text)
            if sec:
                current_section = sec
                continue

            # split left/right (use page width)
            left, right = split_row_lr(row, w)

            # if row is heading-only like "These figures exclude VAT" and no right amount -> skip
            if (not right or right.strip()=="") and not AMOUNT_PATTERN.search(left):
                # no amount anywhere - it's heading or explanatory text; skip itemization
                continue

            # if right contains amount and it's in main area (not sidebar), use it
            amount = None
            # attempt to locate amount span and ensure it's not in sidebar by checking spans' x0
            # find any span in row with amount token and check its x0 relative to thr
            amount_span_amt = None
            for sp in row["spans"]:
                # skip spans in extreme right beyond sidebar threshold
                mid = (sp["x0"] + sp["x1"]) / 2.0
                if mid >= thr:
                    # this span is likely in sidebar - ignore
                    continue
                mm = AMOUNT_PATTERN.search(sp["text"])
                if mm:
                    token = mm.group(1)
                    # ignore year/date tokens
                    if YEAR_RE.search(token) or DATE_RE.search(sp["text"]):
                        continue
                    amount_span_amt = token
                    break
            # fallback: inspect right text (if not in sidebar)
            if amount_span_amt:
                amount = norm_amount(amount_span_amt)
            else:
                # right text may have an amount that is in main body (if right x positions are <= thr)
                # compute average x of right-part spans and ensure it's left of thr
                right_spans = [sp for sp in row["spans"] if ((sp["x0"] + sp["x1"])/2.0) > (w * 0.55)]
                # check if at least one right_span is left of thr
                if any(((sp["x0"] + sp["x1"])/2.0) < thr for sp in right_spans):
                    # attempt extract numeric token from right
                    m = AMOUNT_PATTERN.search(right)
                    if m and not YEAR_RE.search(m.group(1)) and not DATE_RE.search(right):
                        amount = norm_amount(m.group(1))

            # if still no amount, attempt left (rare for discounts that show -111 on left)
            if amount is None:
                mleft = AMOUNT_PATTERN.search(left)
                if mleft:
                    token = mleft.group(1)
                    if not (YEAR_RE.search(token) or DATE_RE.search(left)):
                        # ensure the span holding this token is not sidebar:
                        # find span object that contains token
                        for sp in row["spans"]:
                            if token in sp["text"]:
                                mid = (sp["x0"] + sp["x1"]) / 2.0
                                if mid < thr:
                                    amount = norm_amount(token)
                                    break

            # if there's no amount we skip as non-charge row (explanatory)
            if amount is None:
                continue

            # normalize description left part and remove trailing numeric tokens/dates
            desc = left.strip()
            # remove tokens like ':', dates, month words, '£' etc.
            desc = re.sub(r"\b(£|pounds|GBP)\b", "", desc, flags=re.I)
            desc = re.sub(r"\b(?:\d{1,2}\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)|\d{1,2}/\d{1,2}/\d{2,4})\b", "", desc, flags=re.I)
            desc = re.sub(r"\b(19|20)\d{2}\b", "", desc)
            desc = re.sub(r"[^\w\s\-\&\(\)\,\/\.]", " ", desc)
            desc = re.sub(r"\s+", " ", desc).strip().lower()
            if not desc:
                continue

            # key is (section, desc). Do NOT sum across sections.
            sec_key = current_section or "unknown"
            key = (sec_key, desc)

            # If exact key exists, prefer exact match; else if similarity with same section exists, match; else create new
            matched_key = None
            if key in items:
                matched_key = key
            else:
                # try fuzzy match only within same section
                for (ssec, sdesc) in list(items.keys()):
                    if ssec == sec_key and similar(sdesc, desc) >= 90:
                        matched_key = (ssec, sdesc)
                        break
            if matched_key is None:
                # new entry
                items[key] = {"amount": amount, "example": left, "page": p_idx}
            else:
                # do not SUM across items — keep both? but since they represent same normalized item within same section,
                # in many PDF layouts same item may be split across lines; here we will add amounts if exactly same normalized desc repeated
                # add only if extra amount matches previously (shouldn't happen often)
                # We'll keep last value (or prefer not summing) — keep previous if previous exists; but if previous is zero and new non-zero, replace
                prev = items[matched_key]["amount"]
                if prev == Decimal("0.00"):
                    items[matched_key]["amount"] = amount
                else:
                    # If values differ but represent parts (rare), keep both by making unique key with counter
                    if amount != prev:
                        # create unique key by suffixing counter
                        cnt = 1
                        new_key = (sec_key, f"{desc}__{cnt}")
                        while new_key in items:
                            cnt += 1
                            new_key = (sec_key, f"{desc}__{cnt}")
                        items[new_key] = {"amount": amount, "example": left, "page": p_idx}

    # parse vat & totals scanning rows for 'total excluding vat', 'total vat', 'total for this bill' etc.
    for page in pages_rows:
        w = page["width"]
        thr = page["sidebar_threshold"] or (w * 0.85)
        for row in page["rows"]:
            t = row["text"].lower()
            left, right = split_row_lr(row, w)
            # pick amount from spans that are not in sidebar
            # helper to get amount from row (reusing earlier logic)
            def row_amount(r):
                for sp in r["spans"]:
                    mid = (sp["x0"] + sp["x1"]) / 2.0
                    if mid >= thr:
                        continue
                    mm = AMOUNT_PATTERN.search(sp["text"])
                    if mm:
                        tok = mm.group(1)
                        if YEAR_RE.search(tok) or DATE_RE.search(sp["text"]):
                            continue
                        return norm_amount(tok)
                # fallback to right string scanned earlier
                m = AMOUNT_PATTERN.search(right)
                if m and not YEAR_RE.search(m.group(1)) and not DATE_RE.search(right):
                    return norm_amount(m.group(1))
                return None

            if "total excluding vat" in t or "total for items where vat is charged" in t or "total for items where vat" in t:
                amt = row_amount(row)
                if amt is not None:
                    subtotal = amt
                    vat_summary["total_excluding_vat"] = amt
            elif "vat at" in t or "vat at 20%" in t:
                amt = row_amount(row)
                if amt is not None:
                    vat = amt
                    vat_summary["vat_at_rate"] = amt
            elif "total vat" in t and "total for items" not in t:
                amt = row_amount(row)
                if amt is not None:
                    vat_summary["total_vat"] = amt
            elif "total for this bill" in t or "total owed on this account" in t or t.strip().startswith("total"):
                amt = row_amount(row)
                if amt is not None:
                    total = amt
                    vat_summary["total_for_bill"] = amt

    # convert items keys to string form for JSON/reporting
    items_out = {}
    for (sec, desc), meta in items.items():
        k = f"{sec}||{desc}"
        items_out[k] = {"amount": str(meta["amount"].quantize(Decimal("0.01"))), "example": meta["example"], "page": meta["page"]}
    return pages_rows, items_out, vat_summary, subtotal, vat, total


def parse_pdf(path):
    logger.info("Parsing %s", path)
    pages_spans = extract_spans(path)
    pages_rows, items, vat_summary, subtotal, vat, total = parse_pages(pages_spans)
    account, address = find_account_and_address(pages_rows)
    return ParsedBill(file=os.path.basename(path), account=account, address=address,
                      items=items, vat_summary=vat_summary, subtotal=subtotal, vat=vat, total=total, raw_rows=pages_rows)


# ----- comparison -----

def compare_parsed(a: ParsedBill, b: ParsedBill, tol=Decimal("0.20")):
    diffs = {}
    diffs["account"] = {"a": a.account, "b": b.account, "equal": (a.account == b.account)}
    addr_sim = similar(a.address or "", b.address or "")
    diffs["address"] = {"a": a.address, "b": b.address, "similarity": addr_sim, "equal": (addr_sim >= 90)}

    def approx_eq(x, y):
        if x is None and y is None:
            return True
        if x is None or y is None:
            return False
        try:
            return abs(x - y) <= tol
        except Exception:
            return False

    diffs["subtotal"] = {"a": str(a.subtotal) if a.subtotal else None, "b": str(b.subtotal) if b.subtotal else None, "equal": approx_eq(a.subtotal, b.subtotal)}
    diffs["vat"] = {"a": str(a.vat) if a.vat else None, "b": str(b.vat) if b.vat else None, "equal": approx_eq(a.vat, b.vat)}
    diffs["total"] = {"a": str(a.total) if a.total else None, "b": str(b.total) if b.total else None, "equal": approx_eq(a.total, b.total)}

    # compare items by exact section+desc keys
    keys = set(list(a.items.keys()) + list(b.items.keys()))
    prod_diffs = {}
    for k in sorted(keys):
        ai = a.items.get(k)
        bi = b.items.get(k)
        a_amt = Decimal(ai["amount"]) if ai else None
        b_amt = Decimal(bi["amount"]) if bi else None
        equal = approx_eq(a_amt, b_amt)
        delta = None
        if a_amt is not None and b_amt is not None:
            delta = (b_amt - a_amt).quantize(Decimal("0.01"))
        prod_diffs[k] = {"a_amount": str(a_amt) if a_amt is not None else None,
                         "b_amount": str(b_amt) if b_amt is not None else None,
                         "equal": equal,
                         "delta": str(delta) if delta is not None else None,
                         "example_a": ai["example"] if ai else None,
                         "example_b": bi["example"] if bi else None}
    diffs["items"] = prod_diffs

    # vat summary compare
    vat_keys = set(list(a.vat_summary.keys()) + list(b.vat_summary.keys()))
    vat_diffs = {}
    for k in vat_keys:
        va = a.vat_summary.get(k)
        vb = b.vat_summary.get(k)
        equal = approx_eq(va, vb)
        vat_diffs[k] = {"a": str(va) if va else None, "b": str(vb) if vb else None, "equal": equal}
    diffs["vat_summary"] = vat_diffs

    # score
    top = ["account", "address", "subtotal", "vat", "total"]
    ok = sum(1 for t in top if diffs[t]["equal"])
    diffs["match_score"] = round(ok / len(top) * 100, 1)
    return diffs


# ----- HTML reporting -----

REPORT_TPL = """
<!doctype html>
<html>
<head><meta charset="utf-8"><title>BT Compare: {{a.file}} vs {{b.file}}</title>
<style>body{font-family:Arial;margin:18px}table{width:100%;border-collapse:collapse}th,td{border:1px solid #ddd;padding:8px}th{background:#f5f5f5}.ok{background:#e8f8e8}.diff{background:#fff0f0}.small{font-size:0.9em;color:#555}</style>
</head><body>
<h1>BT Bill Comparison</h1>
<div class="small">Files: <b>{{a.file}}</b> vs <b>{{b.file}}</b> — generated {{now}}</div>
<h2>Account & Address</h2>
<table><tr><th>Field</th><th>Bill A</th><th>Bill B</th><th>Status</th></tr>
<tr class="{{ 'ok' if diffs.account.equal else 'diff'}}"><td>Account</td><td>{{a.account or '—'}}</td><td>{{b.account or '—'}}</td><td>{{'OK' if diffs.account.equal else 'DIFF'}}</td></tr>
<tr class="{{ 'ok' if diffs.address.equal else 'diff'}}"><td>Address</td><td>{{a.address or '—'}}</td><td>{{b.address or '—'}}</td><td>{{ 'OK' if diffs.address.equal else ('Similar: '+ (diffs.address.similarity | string) + '%') }}</td></tr>
</table>

<h2>Totals & VAT</h2>
<table><tr><th>Metric</th><th>Bill A</th><th>Bill B</th><th>Status</th></tr>
<tr class="{{ 'ok' if diffs.subtotal.equal else 'diff'}}"><td>Subtotal (excl VAT)</td><td>{{a.subtotal or '—'}}</td><td>{{b.subtotal or '—'}}</td><td>{{'OK' if diffs.subtotal.equal else 'DIFF'}}</td></tr>
<tr class="{{ 'ok' if diffs.vat.equal else 'diff'}}"><td>VAT</td><td>{{a.vat or '—'}}</td><td>{{b.vat or '—'}}</td><td>{{'OK' if diffs.vat.equal else 'DIFF'}}</td></tr>
<tr class="{{ 'ok' if diffs.total.equal else 'diff'}}"><td>Total (incl VAT)</td><td>{{a.total or '—'}}</td><td>{{b.total or '—'}}</td><td>{{'OK' if diffs.total.equal else 'DIFF'}}</td></tr>
</table>

<h2>VAT Summary</h2>
<table><tr><th>Field</th><th>Bill A</th><th>Bill B</th><th>Status</th></tr>
{% for k,v in diffs.vat_summary.items() %}
<tr class="{{ 'ok' if v.equal else 'diff'}}"><td>{{k}}</td><td>{{v.a or '—'}}</td><td>{{v.b or '—'}}</td><td>{{'OK' if v.equal else 'DIFF'}}</td></tr>
{% endfor %}
</table>

<h2>Line items (section || normalized description)</h2>
<table>
<tr><th>Key (section||desc)</th><th>Example Description</th><th>Bill A Amount</th><th>Bill B Amount</th><th>Delta</th><th>Status</th></tr>
{% for k,v in diffs.items.items() %}
<tr class="{{ 'ok' if v.equal else 'diff'}}">
<td style="width:30%">{{k}}</td>
<td>{{v.example_a or v.example_b or '—'}}</td>
<td>{{v.a_amount or '—'}}</td>
<td>{{v.b_amount or '—'}}</td>
<td>{{v.delta or '—'}}</td>
<td>{{'OK' if v.equal else 'DIFF'}}</td>
</tr>
{% endfor %}
</table>

<h2>Notes</h2>
<ul>
<li>Items are matched only when the <b>section</b> and <b>normalized description</b> match. There is <b>no cross-section summation</b>.</li>
<li>Right-side sidebar numbers (company reg, reference) are excluded from monetary extraction.</li>
<li>Dates and year-like tokens are not treated as amounts.</li>
</ul>

</body></html>
"""

def generate_report(a, b, diffs, outpath):
    tpl = Template(REPORT_TPL)
    content = tpl.render(a=a, b=b, diffs=diffs, now=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
    with open(outpath, "w", encoding="utf-8") as f:
        f.write(content)
    logger.info("Wrote report %s", outpath)


# ----- batch -----

def batch(dirA, dirB, outdir, files=None):
    os.makedirs(outdir, exist_ok=True)
    a_files = sorted([f for f in os.listdir(dirA) if f.lower().endswith(".pdf")])
    b_set = set([f for f in os.listdir(dirB) if f.lower().endswith(".pdf")])
    index = []
    for f in a_files:
        if files and f not in files:
            continue
        if f not in b_set:
            logger.warning("Skipping %s: not present in dirB", f)
            continue
        pa = os.path.join(dirA, f)
        pb = os.path.join(dirB, f)
        try:
            parsed_a = parse_pdf(pa)
            parsed_b = parse_pdf(pb)
            diffs = compare_parsed(parsed_a, parsed_b)
            rname = f.replace(".pdf", "_comparison.html")
            rout = os.path.join(outdir, rname)
            generate_report(parsed_a, parsed_b, diffs, rout)
            index.append({"file": f, "report": rname, "score": diffs["match_score"]})
        except Exception as e:
            logger.exception("Failed compare %s: %s", f, e)
    # write index
    idxp = os.path.join(outdir, "index.html")
    with open(idxp, "w", encoding="utf-8") as ix:
        ix.write("<html><body><h1>Index</h1><table border='1'><tr><th>File</th><th>Report</th><th>Score</th></tr>")
        for e in sorted(index, key=lambda x: x["score"]):
            ix.write(f"<tr><td>{html.escape(e['file'])}</td><td><a href='{html.escape(e['report'])}'>{html.escape(e['report'])}</a></td><td>{e['score']}%</td></tr>")
        ix.write("</table></body></html>")
    logger.info("Done. Reports in %s", outdir)


# ----- CLI -----

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--dirA", required=True)
    p.add_argument("--dirB", required=True)
    p.add_argument("--out", required=True)
    p.add_argument("--debug", action="store_true")
    p.add_argument("--files", nargs="*", default=None)
    args = p.parse_args()
    if args.debug:
        logger.setLevel(logging.DEBUG)
    batch(args.dirA, args.dirB, args.out, files=args.files)


if __name__ == "__main__":
    main()
