#!/usr/bin/env python3
"""
bt_bill_compare_production.py

Production-ready BT bill comparator with enhanced extraction and comparison logic.
- Strict page-1-only extraction for billing address and account number
- Category-aware line-item comparison (no cross-category summation)
- Improved amount detection with date/year filtering
- Professional HTML reporting with detailed diff analysis

Usage:
    python bt_bill_compare_production.py --dirA ./a --dirB ./b --out ./reports

Dependencies:
    pip install pymupdf pillow pytesseract pdf2image jinja2 rapidfuzz
    (system: tesseract, poppler for OCR)
"""

import os
import re
import io
import sys
import argparse
import logging
from datetime import datetime
from decimal import Decimal, InvalidOperation
from collections import defaultdict, namedtuple
from difflib import SequenceMatcher
from typing import Dict, List, Tuple, Optional, Any

# Optional fast fuzzy matching
try:
    from rapidfuzz import fuzz
    HAVE_RAPIDFUZZ = True
except ImportError:
    HAVE_RAPIDFUZZ = False

# PDF & image libraries
try:
    import fitz  # PyMuPDF
    from PIL import Image
    import pytesseract
    from pdf2image import convert_from_path
    from jinja2 import Template
except ImportError as e:
    print("Missing Python dependencies. Install: pip install pymupdf pillow pytesseract pdf2image jinja2 rapidfuzz")
    raise

# Logging configuration
logging.basicConfig(
    level=logging.INFO, 
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("bt_bill_compare.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("bt-bill-compare-production")

AMOUNT_RE = re.compile(r"£?\s*-?\s*([0-9]{1,3}(?:[,\.][0-9]{3})*(?:\.[0-9]{1,2})?|[0-9]+(?:\.[0-9]{1,2})?)")
YEAR_RE = re.compile(r"\b(?:19|20)\d{2}\b")
DATE_RE = re.compile(r"\b(?:\d{1,2}\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)|\d{1,2}/\d{1,2}/\d{2,4})\b", re.I)
ACCOUNT_TOKEN_RE = re.compile(r"(VP\s*\d{4}\s*\d{4}|GP\s*\d{4}\s*\d{4}|[A-Z]{1,3}\s*\d{2,6})", re.I)


# Section keywords for category detection
SECTION_KEYWORDS = {
    "regular_charges": [
        "regular charges", "regular charge", "regular charges -",
        "bundled services", "charges for bundle", "phone services",
        "charges for your", "s fibre", "sogea"
    ],
    "one_off": [
        "one-off charges and credits", "one off charges and credits", 
        "one-off charges", "one off charges", "one-off",
        "bt cloud voice service connection", "bt cloud voice user set-up",
        "bt cloud voice cpe delivery"
    ],
    "discounts": [
        "discounts", "discounts and credits", "discount",
        "loyalty", "credit in advance", "ret loyalty"
    ],
    "usage_charges": [
        "usage charges", "chargeable usage"
    ],
    "vat_summary": [
        "vat summary", "your vat summary", "total vat", "vat at",
        "vat calculation", "items where vat is charged"
    ],
    "charges_detail": [
        "your charges in detail", "charges for", "charges in detail"
    ],
    "overview": [
        "total for this bill", "total owed on this account", "this bill",
        "total which includes", "total", "totals"
    ]
}


# Informational phrases to ignore
INFO_PHRASES = [
    "these figures exclude", "your offer ends on", "there was no chargeable usage",
    "vat at", "total vat", "total for items where vat", "billing address", 
    "account number", "total owed", "total for this bill", "bill date",
    "payment due", "your bill summary", "see page", "continued overleaf",
    "bt order ref", "your order ref", "this is the", "this is your",
    "vat calculation", "items where vat is charged", "vat summary",
    "your vat summary", "total which includes", "amount vat rate",
    "order ref", "your ref", "this is"
]

ParsedBill = namedtuple("ParsedBill", [
    "file", "account", "billing_address", "items", "vat_summary", 
    "subtotal", "vat", "total", "raw_pages"
])

class BillComparisonError(Exception):
    """Custom exception for bill comparison errors"""
    pass

# ----------------------------
# Utility functions
# ----------------------------
def norm_amount_str(s: str) -> Optional[Decimal]:
    """Normalize amount string to Decimal, handling currency symbols and commas"""
    if s is None:
        return None
    s = str(s).strip().replace("£", "").replace(",", "")
    try:
        return Decimal(s).quantize(Decimal("0.01"))
    except (InvalidOperation, ValueError):
        return None

UK_POSTCODE_RE = re.compile(
    r'([A-Z]{1,2}[0-9][A-Z0-9]?[ ]?[0-9][A-Z]{2}|'
    r'GIR[ ]?0AA|'
    r'[A-Z]{1,2}[0-9][ ]?[0-9][A-Z]{2})', 
    re.IGNORECASE
)

def extract_address_with_postcode(page_data: Dict) -> Optional[str]:
    """Extract billing address using UK postcode detection on page 1"""
    if not page_data or "spans" not in page_data:
        return None
    
    rows = group_spans_to_rows(page_data["spans"])
    
    # Find UK postcodes in the page
    postcode_rows = []
    for i, row in enumerate(rows):
        if UK_POSTCODE_RE.search(row["text"]):
            postcode_rows.append((i, row))
    
    if not postcode_rows:
        logger.debug("No UK postcodes found on page 1")
        return None
    
    # For each postcode found, collect address lines by going backwards
    potential_addresses = []
    
    for postcode_idx, postcode_row in postcode_rows:
        address_lines = []
        
        # Start from the postcode row and go backwards up to 6 lines
        start_idx = max(0, postcode_idx - 6)
        
        for idx in range(start_idx, postcode_idx + 1):
            line_text = rows[idx]["text"].strip()
            
            # Skip empty lines and obvious non-address content
            if not line_text:
                continue
            if any(phrase in line_text.lower() for phrase in [
                "account", "invoice", "bill", "date", "page", "vat", "total"
            ]):
                continue
                
            address_lines.append(line_text)
        
        if address_lines:
            potential_address = " | ".join(address_lines)
            potential_addresses.append(potential_address)
    
    # Return the most likely address (usually the first one found)
    if potential_addresses:
        logger.debug(f"Found potential addresses: {potential_addresses}")
        return potential_addresses[0]
    
    return None

def similar(a: str, b: str) -> int:
    """Calculate similarity between two strings (0-100 scale)"""
    if not a or not b:
        return 0
    if HAVE_RAPIDFUZZ:
        return fuzz.token_sort_ratio(a, b)
    else:
        return int(SequenceMatcher(None, a, b).ratio() * 100)

def is_informational_text(text: str) -> bool:
    """Check if text should be treated as informational (non-charge)"""
    text_lower = text.lower()
    
    # Check against known informational phrases
    if any(phrase in text_lower for phrase in INFO_PHRASES):
        return True
    
    # Check if it's primarily a date/year reference
    if DATE_RE.search(text) or YEAR_RE.search(text):
        if not AMOUNT_RE.search(text):
            return True
    
    return False

# ----------------------------
# PDF Text Extraction
# ----------------------------
def extract_spans(pdf_path: str, use_ocr_fallback: bool = True, ocr_dpi: int = 200) -> List[Dict]:
    """
    Extract text spans from PDF with OCR fallback for problematic files
    
    Returns:
        List of page dictionaries with spans and page dimensions
    """
    pages = []
    try:
        doc = fitz.open(pdf_path)
    except Exception as e:
        logger.error(f"Failed to open PDF {pdf_path}: {e}")
        raise BillComparisonError(f"Cannot open PDF: {pdf_path}") from e

    for pnum in range(len(doc)):
        page = doc[pnum]
        page_dict = page.get_text("dict")
        spans = []
        
        for block in page_dict.get("blocks", []):
            if block.get("type") != 0:  # Skip non-text blocks
                continue
            for line in block.get("lines", []):
                for span in line.get("spans", []):
                    text = span.get("text", "").strip()
                    if text:
                        bbox = span.get("bbox", (0, 0, 0, 0))
                        spans.append({
                            "text": text, 
                            "x0": bbox[0], "y0": bbox[1], 
                            "x1": bbox[2], "y1": bbox[3], 
                            "size": span.get("size", 0)
                        })
        
        # OCR fallback for sparse pages
        if use_ocr_fallback and len(spans) < 10:
            try:
                logger.debug(f"Using OCR fallback for page {pnum} in {pdf_path}")
                pix = page.get_pixmap(dpi=ocr_dpi)
                img = Image.open(io.BytesIO(pix.tobytes("png"))).convert("RGB")
                ocr_text = pytesseract.image_to_string(img)
                
                # Create synthetic spans from OCR text
                base_y = page.rect.y1 - 30
                for i, line in enumerate([l for l in ocr_text.splitlines() if l.strip()]):
                    spans.append({
                        "text": line.strip(), 
                        "x0": 50, "y0": base_y + i * 12, 
                        "x1": page.rect.x1 - 50, "y1": base_y + i * 12 + 10, 
                        "size": 10
                    })
            except Exception as ocr_error:
                logger.warning(f"OCR fallback failed for {pdf_path} page {pnum}: {ocr_error}")
        
        pages.append({
            "width": page.rect.x1, 
            "height": page.rect.y1, 
            "spans": spans,
            "page_num": pnum
        })
    
    doc.close()
    return pages

def group_spans_to_rows(spans: List[Dict], y_tol: int = 3) -> List[Dict]:
    """Group spans into rows based on Y-coordinate alignment"""
    if not spans:
        return []
    
    # Sort spans by Y then X coordinates
    sorted_spans = sorted(spans, key=lambda s: (round(s["y0"]), s["x0"]))
    
    rows = []
    current_y = None
    current_row = []
    
    for span in sorted_spans:
        y_pos = round(span["y0"])
        
        if current_y is None:
            current_y = y_pos
            current_row = [span]
        elif abs(y_pos - current_y) <= y_tol:
            current_row.append(span)
        else:
            # Finalize current row and start new one
            rows.append(sorted(current_row, key=lambda s: s["x0"]))
            current_row = [span]
            current_y = y_pos
    
    if current_row:
        rows.append(sorted(current_row, key=lambda s: s["x0"]))
    
    # Convert to structured rows
    structured_rows = []
    for row in rows:
        text = " ".join([span["text"] for span in row])
        structured_rows.append({
            "y": row[0]["y0"], 
            "spans": row, 
            "text": text
        })
    
    return structured_rows

def detect_sidebar_threshold(spans: List[Dict]) -> float:
    """Detect X threshold for sidebar content using 85th percentile heuristic"""
    if not spans:
        return 0.0
    
    x_positions = sorted([span["x0"] for span in spans])
    if not x_positions:
        return 0.0
    
    idx = int(len(x_positions) * 0.85)
    percentile_85 = x_positions[min(idx, len(x_positions) - 1)]
    return percentile_85 - 5

# ----------------------------
# Page 1 Extraction (Account & Address)
# ----------------------------
def extract_account_from_page1(page_data: Dict) -> Optional[str]:
    """
    Extract account number from page 1 top-right corner
    
    Looks for patterns like:
    Account number    VP 0024 5678
    """
    if not page_data or "spans" not in page_data:
        return None
    
    page_width = page_data["width"]
    page_height = page_data["height"]
    rows = group_spans_to_rows(page_data["spans"])
    sidebar_threshold = detect_sidebar_threshold(page_data["spans"]) or (page_width * 0.75)
    
    # Strategy 1: Look for "Account" label in top-right region
    for row in rows:
        # Focus on top 30% of page
        if row["y"] > page_height * 0.3:
            continue
            
        for span in row["spans"]:
            span_center = (span["x0"] + span["x1"]) / 2.0
            # Check if span is in right portion of page
            if span_center < page_width * 0.6:
                continue
                
            text = span["text"].lower()
            if "account" in text:
                # Extract account number from this row
                account_candidates = []
                for row_span in row["spans"]:
                    if ACCOUNT_TOKEN_RE.search(row_span["text"]):
                        account_candidates.append(row_span["text"].strip())
                
                if account_candidates:
                    # Join and clean account number
                    account_text = " ".join(account_candidates)
                    match = ACCOUNT_TOKEN_RE.search(account_text)
                    if match:
                        return match.group(1).strip()
    
    # Strategy 2: Direct search for account patterns in top-right
    for row in rows:
        if row["y"] > page_height * 0.3:
            continue
            
        for span in row["spans"]:
            span_center = (span["x0"] + span["x1"]) / 2.0
            if span_center < sidebar_threshold:
                continue
                
            match = ACCOUNT_TOKEN_RE.search(span["text"])
            if match:
                return match.group(1).strip()
    
    return None

def extract_billing_address_from_page1(page_data: Dict) -> Optional[str]:
    """Extract billing address from page 1 only"""
    if not page_data or "spans" not in page_data:
        return None
    
    rows = group_spans_to_rows(page_data["spans"])
    address_lines = []
    found_billing_address = False
    
    for i, row in enumerate(rows):
        text_lower = row["text"].lower()
        
        # Look for billing address label
        if "billing address" in text_lower:
            found_billing_address = True
            # Collect following lines (up to 8 lines or until section break)
            for j in range(i + 1, min(len(rows), i + 9)):
                next_row = rows[j]
                next_text = next_row["text"].strip()
                
                # Stop at empty lines or new sections
                if not next_text:
                    break
                if detect_section_for_text(next_text):
                    break
                    
                address_lines.append(next_text)
            break
    
    if address_lines:
        # Clean and join address lines
        cleaned_address = " ".join([line.strip() for line in address_lines])
        return re.sub(r'\s+', ' ', cleaned_address).strip()
    
    return None

def extract_page1_data(pages_spans: List[Dict]) -> Tuple[Optional[str], Optional[str]]:
    """Extract account and billing address from page 1 only"""
    if not pages_spans:
        return None, None
    
    page1 = pages_spans[0]
    account = extract_account_from_page1(page1)
    
    # Try multiple address extraction strategies
    address = None
    
    # Strategy 1: UK Postcode detection
    address = extract_address_with_postcode(page1)
    
    # Strategy 2: Fallback to original billing address detection
    if not address:
        address = extract_billing_address_from_page1(page1)
    
    # Strategy 3: Look for common address patterns
    if not address:
        address = find_address_by_patterns(page1)
    
    logger.info(f"Extracted - Account: {account}, Address: {address}")
    return account, address

def find_address_by_patterns(page_data: Dict) -> Optional[str]:
    """Fallback address detection using common patterns"""
    if not page_data or "spans" not in page_data:
        return None
    
    rows = group_spans_to_rows(page_data["spans"])
    address_keywords = ["street", "road", "lane", "avenue", "drive", "close", "court"]
    
    for i, row in enumerate(rows):
        text_lower = row["text"].lower()
        
        # Look for lines that might contain address elements
        if any(keyword in text_lower for keyword in address_keywords):
            # Collect surrounding lines
            address_lines = []
            start_idx = max(0, i - 3)
            end_idx = min(len(rows), i + 4)
            
            for idx in range(start_idx, end_idx):
                line_text = rows[idx]["text"].strip()
                if line_text and not any(phrase in line_text.lower() for phrase in [
                    "account", "invoice", "bill", "date", "page"
                ]):
                    address_lines.append(line_text)
            
            if address_lines:
                return " | ".join(address_lines)
    
    return None

# ----------------------------
# Section and Line Item Processing
# ----------------------------
def detect_section_for_text(text: str) -> Optional[str]:
    """Detect which section the text belongs to"""
    text_lower = text.lower()
    
    for section_key, keywords in SECTION_KEYWORDS.items():
        for keyword in keywords:
            if keyword in text_lower:
                return section_key
    return None

def extract_amount_from_row(row: Dict, page_width: float, sidebar_threshold: float) -> Optional[str]:
    """
    Enhanced amount extraction with better right-side detection
    """
    # Prioritize spans in the far right area (likely amounts)
    rightmost_spans = [
        span for span in row["spans"] 
        if span["x1"] > page_width * 0.7 and span["x1"] < sidebar_threshold
    ]
    
    # Check rightmost spans first
    for span in sorted(rightmost_spans, key=lambda s: s["x1"], reverse=True):
        amount_match = AMOUNT_RE.search(span["text"])
        if amount_match:
            amount_text = amount_match.group(1)
            # Filter out dates and years
            if not (YEAR_RE.search(amount_text) or DATE_RE.search(span["text"])):
                logger.debug(f"Found amount in rightmost span: {amount_text} from '{span['text']}'")
                return amount_text
    
    # Fallback: check all spans in main content area
    for span in row["spans"]:
        if span["x1"] >= sidebar_threshold:
            continue  # Skip sidebar spans
            
        amount_match = AMOUNT_RE.search(span["text"])
        if amount_match:
            amount_text = amount_match.group(1)
            if not (YEAR_RE.search(amount_text) or DATE_RE.search(span["text"])):
                logger.debug(f"Found amount in main span: {amount_text} from '{span['text']}'")
                return amount_text
    
    return None

def normalize_line_description(text: str) -> str:
    """Normalize line item description for consistent matching"""
    if not text:
        return ""
    
    # Remove currency symbols, amounts, dates, and special characters
    cleaned = re.sub(r"[£$€]\s*\d+\.?\d*", "", text)  # Currency amounts
    cleaned = re.sub(r"\b\d{1,2}\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{4}\b", "", cleaned, flags=re.I)  # Dates
    cleaned = re.sub(r"\b(?:19|20)\d{2}\b", "", cleaned)  # Years
    cleaned = re.sub(r"[^\w\s\-&()/,.]", " ", cleaned)  # Special chars
    cleaned = re.sub(r"\s+", " ", cleaned)  # Multiple spaces
    cleaned = cleaned.strip().lower()
    
    return cleaned

def parse_line_items(pages_spans: List[Dict]) -> Tuple[Dict, Dict, Optional[Decimal], Optional[Decimal], Optional[Decimal]]:
    """
    Parse line items with proper totals and VAT extraction
    """
    items = {}
    current_section = None
    vat_summary = {}
    subtotal = vat = total = None
    
    for page_idx, page in enumerate(pages_spans):
        page_width = page["width"]
        sidebar_threshold = detect_sidebar_threshold(page["spans"]) or (page_width * 0.8)
        rows = group_spans_to_rows(page["spans"])
        
        for row in rows:
            text = row["text"].strip()
            if not text:
                continue
            
            # Section detection
            section = detect_section_for_text(text)
            if section:
                current_section = section
                continue
            
            # Skip informational text without amounts
            if is_informational_text(text):
                continue
            
            # SPECIAL HANDLING: Extract totals and VAT from specific patterns
            text_lower = text.lower()
            
            # Extract Total (most important)
            if any(phrase in text_lower for phrase in [
                "total for this bill", "total owed", "total including vat", 
                "total amount", "bill total", "total payable"
            ]):
                amount_text = extract_amount_from_row(row, page_width, sidebar_threshold)
                if amount_text:
                    total = norm_amount_str(amount_text)
                    vat_summary["total_for_bill"] = total
                    logger.info(f"Found Total: {total} in text: {text}")
                continue
            
            # Extract Subtotal (total excluding VAT)
            if any(phrase in text_lower for phrase in [
                "total excluding vat", "subtotal", "net total", "total before vat"
            ]):
                amount_text = extract_amount_from_row(row, page_width, sidebar_threshold)
                if amount_text:
                    subtotal = norm_amount_str(amount_text)
                    vat_summary["total_excluding_vat"] = subtotal
                    logger.info(f"Found Subtotal: {subtotal} in text: {text}")
                continue
            
            # Extract VAT amount
            if any(phrase in text_lower for phrase in [
                "vat at", "total vat", "vat amount", "vat charged"
            ]) and "vat summary" not in text_lower:
                amount_text = extract_amount_from_row(row, page_width, sidebar_threshold)
                if amount_text:
                    vat = norm_amount_str(amount_text)
                    vat_summary["total_vat"] = vat
                    logger.info(f"Found VAT: {vat} in text: {text}")
                continue
            
            # Extract VAT summary details
            if "vat summary" in text_lower or "vat calculation" in text_lower:
                # Look for VAT rate details in subsequent rows
                for next_row in rows[rows.index(row) + 1:rows.index(row) + 5]:
                    next_text = next_row["text"].lower()
                    if "vat at" in next_text and "%" in next_text:
                        amount_text = extract_amount_from_row(next_row, page_width, sidebar_threshold)
                        if amount_text:
                            vat_summary["vat_at_20_percent"] = norm_amount_str(amount_text)
                            logger.info(f"Found VAT at 20%: {amount_text}")
            
            # Regular line item processing (only if we haven't already processed this as a total/VAT)
            amount_text = extract_amount_from_row(row, page_width, sidebar_threshold)
            if not amount_text:
                continue
            
            amount_value = norm_amount_str(amount_text)
            if amount_value is None:
                continue
            
            # Extract and normalize description from left portion
            left_text = " ".join([
                span["text"] for span in row["spans"] 
                if (span["x0"] + span["x1"]) / 2.0 < page_width * 0.6
            ]).strip()
            
            if not left_text:
                continue
                
            normalized_desc = normalize_line_description(left_text)
            if not normalized_desc:
                continue
            
            # Use category + description as unique key
            section_key = current_section or "unknown"
            item_key = (section_key, normalized_desc)
            
            # Handle duplicate items within same category
            if item_key in items:
                counter = 1
                new_key = (section_key, f"{normalized_desc}__dup{counter}")
                while new_key in items:
                    counter += 1
                    new_key = (section_key, f"{normalized_desc}__dup{counter}")
                item_key = new_key
            
            items[item_key] = {
                "amount": amount_value,
                "example": left_text,
                "page": page_idx
            }
    
    # Convert items to string-keyed dict for JSON serialization
    items_out = {}
    for (section, desc), meta in items.items():
        key = f"{section}||{desc}"
        items_out[key] = {
            "amount": str(meta["amount"].quantize(Decimal("0.01"))),
            "example": meta["example"],
            "page": meta["page"]
        }
    
    # Log what we found for debugging
    logger.info(f"Parsing Results - Subtotal: {subtotal}, VAT: {vat}, Total: {total}")
    logger.info(f"VAT Summary: {vat_summary}")
    logger.info(f"Line Items: {len(items_out)} items")
    
    return items_out, vat_summary, subtotal, vat, total




# ----------------------------
# Main PDF Parser
# ----------------------------
def parse_pdf_bill(pdf_path: str) -> ParsedBill:
    """Main function to parse a PDF bill"""
    logger.info(f"Parsing PDF: {pdf_path}")
    
    try:
        pages_spans = extract_spans(pdf_path)
        account, billing_address = extract_page1_data(pages_spans)
        items, vat_summary, subtotal, vat, total = parse_line_items(pages_spans)
        
        return ParsedBill(
            file=os.path.basename(pdf_path),
            account=account,
            billing_address=billing_address,
            items=items,
            vat_summary=vat_summary,
            subtotal=subtotal,
            vat=vat,
            total=total,
            raw_pages=pages_spans
        )
    except Exception as e:
        logger.error(f"Failed to parse {pdf_path}: {e}")
        raise BillComparisonError(f"PDF parsing failed: {pdf_path}") from e

# ----------------------------
# Comparison Logic
# ----------------------------
def calculate_comprehensive_match_score(differences: Dict[str, Any]) -> float:
    """Calculate more comprehensive match score including line items"""
    
    weights = {
        'account': 10,           # 10% weight
        'address': 10,           # 10% weight  
        'subtotal': 15,          # 15% weight
        'vat': 15,               # 15% weight
        'total': 20,             # 20% weight (most important)
        'line_items': 30         # 30% weight for all line items
    }
    
    total_score = 0
    
    # Top-level fields (60% total)
    for field in ['account', 'address', 'subtotal', 'vat', 'total']:
        if differences[field]['equal']:
            total_score += weights[field]
    
    # Line items comparison (30% total)
    if 'items' in differences and differences['items']:
        items_data = differences['items']
        matching_items = sum(1 for item in items_data.values() if item.get('equal', False))
        total_items = len(items_data)
        
        if total_items > 0:
            line_item_score = (matching_items / total_items) * weights['line_items']
            total_score += line_item_score
    
    # VAT summary (10% - if present)
    if 'vat_summary' in differences and differences['vat_summary']:
        vat_data = differences['vat_summary']
        matching_vat = sum(1 for vat_item in vat_data.values() if vat_item.get('equal', False))
        total_vat = len(vat_data)
        
        if total_vat > 0:
            vat_score = (matching_vat / total_vat) * 10  # 10% weight
            total_score += vat_score
    
    return round(total_score, 1)


def compare_bills(bill_a: ParsedBill, bill_b: ParsedBill, amount_tolerance: Decimal = Decimal("0.01")) -> Dict[str, Any]:
    """Compare two parsed bills and generate detailed differences"""
    
    def amounts_equal(amt_a, amt_b, tol=amount_tolerance):
        """Check if two amounts are equal within tolerance"""
        if amt_a is None and amt_b is None:
            return True
        if amt_a is None or amt_b is None:
            return False
        try:
            return abs(Decimal(amt_a) - Decimal(amt_b)) <= tol
        except (InvalidOperation, TypeError):
            return False
    
    # Initialize differences as a plain dictionary
    differences = {}
    
    differences["account"] = {
        "a": bill_a.account, "b": bill_b.account, 
        "equal": bill_a.account == bill_b.account,
        "status": "OK" if bill_a.account == bill_b.account else "DIFF"
    }
    
    address_similarity = similar(bill_a.billing_address or "", bill_b.billing_address or "")
    differences["address"] = {
        "a": bill_a.billing_address, "b": bill_b.billing_address,
        "similarity": address_similarity,
        "equal": address_similarity >= 90,
        "status": "OK" if address_similarity >= 90 else "DIFF"
    }
    
    differences["subtotal"] = {
        "a": str(bill_a.subtotal) if bill_a.subtotal else None,
        "b": str(bill_b.subtotal) if bill_b.subtotal else None,
        "equal": amounts_equal(bill_a.subtotal, bill_b.subtotal),
        "status": "OK" if amounts_equal(bill_a.subtotal, bill_b.subtotal) else "DIFF"
    }
    
    differences["vat"] = {
        "a": str(bill_a.vat) if bill_a.vat else None,
        "b": str(bill_b.vat) if bill_b.vat else None,
        "equal": amounts_equal(bill_a.vat, bill_b.vat),
        "status": "OK" if amounts_equal(bill_a.vat, bill_b.vat) else "DIFF"
    }
    
    differences["total"] = {
        "a": str(bill_a.total) if bill_a.total else None,
        "b": str(bill_b.total) if bill_b.total else None,
        "equal": amounts_equal(bill_a.total, bill_b.total),
        "status": "OK" if amounts_equal(bill_a.total, bill_b.total) else "DIFF"
    }
    
    # FIXED: Line item comparison - proper set union
    all_keys = sorted(set(bill_a.items.keys()) | set(bill_b.items.keys()))
    items_comparison = {}
    
    for key in all_keys:
        item_a = bill_a.items.get(key)
        item_b = bill_b.items.get(key)
        
        amount_a = Decimal(item_a["amount"]) if item_a else None
        amount_b = Decimal(item_b["amount"]) if item_b else None
        
        if amount_a is None and amount_b is None:
            status = "N/A"
        elif amount_a is None:
            status = "Missing in File A"
        elif amount_b is None:
            status = "Missing in File B"
        elif amounts_equal(amount_a, amount_b):
            status = "OK"
        else:
            status = "DIFF"
        
        delta = None
        if amount_a is not None and amount_b is not None:
            delta = (amount_b - amount_a).quantize(Decimal("0.01"))
        
        items_comparison[key] = {
            "a_amount": str(amount_a) if amount_a is not None else None,
            "b_amount": str(amount_b) if amount_b is not None else None,
            "equal": status == "OK",
            "delta": str(delta) if delta is not None else None,
            "status": status,
            "example_a": item_a["example"] if item_a else None,
            "example_b": item_b["example"] if item_b else None
        }
    
    differences["items"] = items_comparison
    
    # FIXED: VAT summary comparison - proper set union
    vat_keys = set(bill_a.vat_summary.keys()) | set(bill_b.vat_summary.keys())
    vat_summary_comparison = {}
    
    for key in vat_keys:
        va = bill_a.vat_summary.get(key)
        vb = bill_b.vat_summary.get(key)
        vat_summary_comparison[key] = {
            "a": str(va) if va else None,
            "b": str(vb) if vb else None,
            "equal": amounts_equal(va, vb)
        }
    
    differences["vat_summary"] = vat_summary_comparison
    
    # Calculate overall match score
    top_level_checks = ["account", "address", "subtotal", "vat", "total"]
    matching_checks = sum(1 for check in top_level_checks if differences[check]["equal"])
    match_score = round((matching_checks / len(top_level_checks)) * 100, 1)
    differences["match_score"] = calculate_comprehensive_match_score(differences)
    
    # Ensure we return a plain dictionary
    return dict(differences)

# ----------------------------
# HTML Reporting
# ----------------------------
HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BT Bill Comparison - {{a.file}} vs {{b.file}}</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; background: #f8f9fa; margin: 0; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #0047ab; margin-bottom: 10px; border-bottom: 2px solid #0047ab; padding-bottom: 10px; }
        h2 { color: #0056b3; margin: 25px 0 15px 0; padding-bottom: 8px; border-bottom: 1px solid #e0e0e0; }
        .header-info { background: #e8f4ff; padding: 15px; border-radius: 6px; margin-bottom: 20px; }
        .score { display: inline-block; padding: 8px 16px; border-radius: 20px; font-weight: bold; margin: 10px 0; }
        .score-high { background: #d4edda; color: #155724; }
        .score-medium { background: #fff3cd; color: #856404; }
        .score-low { background: #f8d7da; color: #721c24; }
        table { width: 100%; border-collapse: collapse; margin: 15px 0; background: white; }
        th, td { padding: 12px 15px; text-align: left; border: 1px solid #dee2e6; }
        th { background: #0047ab; color: white; font-weight: 600; }
        tr:nth-child(even) { background: #f8f9fa; }
        .status-ok { background: #d4edda; color: #155724; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
        .status-diff { background: #f8d7da; color: #721c24; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
        .status-missing { background: #fff3cd; color: #856404; padding: 4px 8px; border-radius: 4px; font-weight: bold; }
        .delta-positive { color: #dc3545; font-weight: bold; }
        .delta-negative { color: #28a745; font-weight: bold; }
        .section { margin-bottom: 30px; }
        .timestamp { color: #6c757d; font-size: 0.9em; margin-bottom: 20px; }
        .file-info { display: flex; justify-content: space-between; flex-wrap: wrap; gap: 20px; margin: 15px 0; }
        .file-card { flex: 1; min-width: 300px; background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 4px solid #0047ab; }
    </style>
</head>
<body>
    <div class="container">
        <h1>BT Bill Comparison Report</h1>
        <div class="timestamp">Generated: {{now}}</div>
        
        <div class="header-info">
            <div class="file-info">
                <div class="file-card">
                    <strong>File A:</strong> {{a.file}}<br>
                    <strong>Account:</strong> {{a.account or 'Not found'}}<br>
                    <strong>Address:</strong> {{a.billing_address or 'Not found'}}
                </div>
                <div class="file-card">
                    <strong>File B:</strong> {{b.file}}<br>
                    <strong>Account:</strong> {{b.account or 'Not found'}}<br>
                    <strong>Address:</strong> {{b.billing_address or 'Not found'}}
                </div>
            </div>
            
            <div>
                <strong>Match Score: </strong>
                {% if diffs.match_score >= 90 %}
                <span class="score score-high">{{ diffs.match_score }}%</span>
                {% elif diffs.match_score >= 70 %}
                <span class="score score-medium">{{ diffs.match_score }}%</span>
                {% else %}
                <span class="score score-low">{{ diffs.match_score }}%</span>
                {% endif %}
            </div>
        </div>

        <!-- Basic comparisons (non-iterative) -->
        <div class="section">
            <h2>Account & Billing Address Comparison</h2>
            <table>
                <thead>
                    <tr>
                        <th>Field</th>
                        <th>Bill A</th>
                        <th>Bill B</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Account Number</td>
                        <td>{{ diffs.account.a or '—' }}</td>
                        <td>{{ diffs.account.b or '—' }}</td>
                        <td>
                            {% if diffs.account.equal %}
                            <span class="status-ok">OK</span>
                            {% else %}
                            <span class="status-diff">DIFF</span>
                            {% endif %}
                        </td>
                    </tr>
                    <tr>
                        <td>Billing Address</td>
                        <td>{{ diffs.address.a or '—' }}</td>
                        <td>{{ diffs.address.b or '—' }}</td>
                        <td>
                            {% if diffs.address.equal %}
                            <span class="status-ok">OK</span>
                            {% else %}
                            <span class="status-diff">DIFF ({{ diffs.address.similarity }}% similar)</span>
                            {% endif %}
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section">
            <h2>Summary Totals</h2>
            <table>
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Bill A</th>
                        <th>Bill B</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Subtotal (excl VAT)</td>
                        <td>{{ diffs.subtotal.a or '—' }}</td>
                        <td>{{ diffs.subtotal.b or '—' }}</td>
                        <td>
                            {% if diffs.subtotal.equal %}
                            <span class="status-ok">OK</span>
                            {% else %}
                            <span class="status-diff">DIFF</span>
                            {% endif %}
                        </td>
                    </tr>
                    <tr>
                        <td>VAT</td>
                        <td>{{ diffs.vat.a or '—' }}</td>
                        <td>{{ diffs.vat.b or '—' }}</td>
                        <td>
                            {% if diffs.vat.equal %}
                            <span class="status-ok">OK</span>
                            {% else %}
                            <span class="status-diff">DIFF</span>
                            {% endif %}
                        </td>
                    </tr>
                    <tr>
                        <td>Total (incl VAT)</td>
                        <td>{{ diffs.total.a or '—' }}</td>
                        <td>{{ diffs.total.b or '—' }}</td>
                        <td>
                            {% if diffs.total.equal %}
                            <span class="status-ok">OK</span>
                            {% else %}
                            <span class="status-diff">DIFF</span>
                            {% endif %}
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- Line Items with SAFE iteration -->
        <div class="section">
            <h2>Line Item Comparison</h2>
            <table>
                <thead>
                    <tr>
                        <th>Category & Description</th>
                        <th>Example</th>
                        <th>Bill A Amount</th>
                        <th>Bill B Amount</th>
                        <th>Delta (B - A)</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    {% if diffs.items %}
                        {% for key, item in diffs.items.items() %}
                        <tr>
                            <td><strong>{{ key }}</strong></td>
                            <td>{{ item.example_a or item.example_b or '—' }}</td>
                            <td>{{ item.a_amount or '—' }}</td>
                            <td>{{ item.b_amount or '—' }}</td>
                            <td>
                                {% if item.delta %}
                                    {% if item.delta.startswith('-') %}
                                    <span class="delta-negative">{{ item.delta }}</span>
                                    {% else %}
                                    <span class="delta-positive">+{{ item.delta }}</span>
                                    {% endif %}
                                {% else %}
                                    —
                                {% endif %}
                            </td>
                            <td>
                                {% if item.status == 'OK' %}
                                <span class="status-ok">OK</span>
                                {% elif item.status == 'DIFF' %}
                                <span class="status-diff">DIFF</span>
                                {% elif 'Missing' in item.status %}
                                <span class="status-missing">{{ item.status }}</span>
                                {% else %}
                                <span class="status-missing">{{ item.status }}</span>
                                {% endif %}
                            </td>
                        </tr>
                        {% endfor %}
                    {% else %}
                        <tr>
                            <td colspan="6" style="text-align: center;">No line items found</td>
                        </tr>
                    {% endif %}
                </tbody>
            </table>
        </div>

        <!-- VAT Summary with SAFE iteration -->
        {% if diffs.vat_summary %}
        <div class="section">
            <h2>VAT Summary</h2>
            <table>
                <thead>
                    <tr>
                        <th>VAT Item</th>
                        <th>Bill A</th>
                        <th>Bill B</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    {% for key, vat_item in diffs.vat_summary.items() %}
                    <tr>
                        <td>{{ key }}</td>
                        <td>{{ vat_item.a or '—' }}</td>
                        <td>{{ vat_item.b or '—' }}</td>
                        <td>
                            {% if vat_item.equal %}
                            <span class="status-ok">OK</span>
                            {% else %}
                            <span class="status-diff">DIFF</span>
                            {% endif %}
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
        {% endif %}
    </div>
</body>
</html>"""

def generate_comparison_report(bill_a: ParsedBill, bill_b: ParsedBill, 
                             differences: Dict[str, Any], output_path: str) -> None:
    """Generate HTML comparison report"""
    try:
        template = Template(HTML_TEMPLATE)
        
        # Prepare bill data for reporting
        bill_a_report = {
            'file': bill_a.file,
            'account': bill_a.account,
            'billing_address': bill_a.billing_address,
            'subtotal': str(bill_a.subtotal) if bill_a.subtotal else None,
            'vat': str(bill_a.vat) if bill_a.vat else None,
            'total': str(bill_a.total) if bill_a.total else None,
        }
        
        bill_b_report = {
            'file': bill_b.file,
            'account': bill_b.account,
            'billing_address': bill_b.billing_address,
            'subtotal': str(bill_b.subtotal) if bill_b.subtotal else None,
            'vat': str(bill_b.vat) if bill_b.vat else None,
            'total': str(bill_b.total) if bill_b.total else None,
        }
        
        # COMPLETELY SAFE: Convert everything to basic types and ensure iterables
        differences_clean = {
            'match_score': differences.get('match_score', 0)
        }
        
        # Convert all nested structures
        for key in ['account', 'address', 'subtotal', 'vat', 'total']:
            if key in differences:
                differences_clean[key] = dict(differences[key])
        
        # Safely handle items - ensure it's a proper dictionary
        if 'items' in differences:
            items_clean = {}
            items_data = differences['items']
            # Convert to proper dict if needed
            if hasattr(items_data, 'items') and callable(items_data.items):
                items_data = dict(items_data.items())
            
            for item_key, item_value in items_data.items():
                items_clean[item_key] = dict(item_value) if isinstance(item_value, dict) else item_value
            differences_clean['items'] = items_clean
        
        # Safely handle vat_summary
        if 'vat_summary' in differences:
            vat_clean = {}
            vat_data = differences['vat_summary']
            # Convert to proper dict if needed
            if hasattr(vat_data, 'items') and callable(vat_data.items):
                vat_data = dict(vat_data.items())
            
            for vat_key, vat_value in vat_data.items():
                vat_clean[vat_key] = dict(vat_value) if isinstance(vat_value, dict) else vat_value
            differences_clean['vat_summary'] = vat_clean
        
        logger.debug("=== FINAL CHECK ===")
        logger.debug(f"differences_clean type: {type(differences_clean)}")
        logger.debug(f"differences_clean keys: {list(differences_clean.keys())}")
        
        # Verify everything is iterable
        for key, value in differences_clean.items():
            logger.debug(f"Key '{key}': type {type(value)}, iterable: {hasattr(value, '__iter__')}")
            if key in ['items', 'vat_summary'] and value:
                sample_key = next(iter(value.keys())) if value else "empty"
                logger.debug(f"  Sample inner key: {sample_key}")
        
        rendered_html = template.render(
            a=bill_a_report,
            b=bill_b_report,
            diffs=differences_clean,
            now=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        )
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(rendered_html)
        
        logger.info(f"Generated comparison report: {output_path}")
        
    except Exception as e:
        logger.error(f"Failed to generate report {output_path}: {e}")
        import traceback
        logger.error(f"Full traceback: {traceback.format_exc()}")
        raise

def generate_text_report(bill_a: ParsedBill, bill_b: ParsedBill, 
                        differences: Dict[str, Any], output_path: str) -> None:
    """Generate a simple text comparison report"""
    
    report_lines = []
    report_lines.append("=" * 80)
    report_lines.append(f"BT BILL COMPARISON REPORT")
    report_lines.append("=" * 80)
    report_lines.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    report_lines.append(f"File A: {bill_a.file}")
    report_lines.append(f"File B: {bill_b.file}")
    report_lines.append(f"Match Score: {differences.get('match_score', 0)}%")
    report_lines.append("")
    
    # Account & Address
    report_lines.append("ACCOUNT & ADDRESS")
    report_lines.append("-" * 40)
    report_lines.append(f"Account A: {bill_a.account or 'Not found'}")
    report_lines.append(f"Account B: {bill_b.account or 'Not found'}")
    report_lines.append(f"Status: {'OK' if differences['account']['equal'] else 'DIFF'}")
    report_lines.append("")
    report_lines.append(f"Address A: {bill_a.billing_address or 'Not found'}")
    report_lines.append(f"Address B: {bill_b.billing_address or 'Not found'}")
    report_lines.append(f"Status: {'OK' if differences['address']['equal'] else 'DIFF'}")
    report_lines.append("")
    
    # Summary Totals
    report_lines.append("SUMMARY TOTALS")
    report_lines.append("-" * 40)
    for field in ['subtotal', 'vat', 'total']:
        diff_data = differences[field]
        report_lines.append(f"{field.upper()}:")
        report_lines.append(f"  A: {diff_data['a'] or '—'}")
        report_lines.append(f"  B: {diff_data['b'] or '—'}")
        report_lines.append(f"  Status: {'OK' if diff_data['equal'] else 'DIFF'}")
    report_lines.append("")
    
    # Line Items
    report_lines.append("LINE ITEMS")
    report_lines.append("-" * 40)
    if 'items' in differences:
        items_data = differences['items']
        for key, item in items_data.items():
            report_lines.append(f"ITEM: {key}")
            report_lines.append(f"  Example: {item.get('example_a') or item.get('example_b') or '—'}")
            report_lines.append(f"  Amount A: {item.get('a_amount') or '—'}")
            report_lines.append(f"  Amount B: {item.get('b_amount') or '—'}")
            report_lines.append(f"  Delta: {item.get('delta') or '—'}")
            report_lines.append(f"  Status: {item.get('status', 'UNKNOWN')}")
            report_lines.append("")
    else:
        report_lines.append("No line items found")
        report_lines.append("")
    
    # VAT Summary
    if 'vat_summary' in differences and differences['vat_summary']:
        report_lines.append("VAT SUMMARY")
        report_lines.append("-" * 40)
        for key, vat_item in differences['vat_summary'].items():
            report_lines.append(f"{key}:")
            report_lines.append(f"  A: {vat_item.get('a') or '—'}")
            report_lines.append(f"  B: {vat_item.get('b') or '—'}")
            report_lines.append(f"  Status: {'OK' if vat_item.get('equal') else 'DIFF'}")
        report_lines.append("")
    
    # Write to file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(report_lines))
    
    logger.info(f"Generated text report: {output_path}")


import csv

def generate_csv_report(bill_a: ParsedBill, bill_b: ParsedBill, 
                       differences: Dict[str, Any], output_path: str) -> None:
    """Generate CSV comparison report"""
    
    with open(output_path, 'w', newline='', encoding='utf-8') as csvfile:
        writer = csv.writer(csvfile)
        
        # Header
        writer.writerow(["BT Bill Comparison Report"])
        writer.writerow([f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"])
        writer.writerow([f"File A: {bill_a.file}"])
        writer.writerow([f"File B: {bill_b.file}"])
        writer.writerow([f"Match Score: {differences.get('match_score', 0)}%"])
        writer.writerow([])
        
        # Account & Address
        writer.writerow(["ACCOUNT & ADDRESS"])
        writer.writerow(["Field", "Bill A", "Bill B", "Status"])
        writer.writerow([
            "Account", 
            bill_a.account or "Not found", 
            bill_b.account or "Not found", 
            "OK" if differences['account']['equal'] else "DIFF"
        ])
        writer.writerow([
            "Address", 
            bill_a.billing_address or "Not found", 
            bill_b.billing_address or "Not found", 
            "OK" if differences['address']['equal'] else "DIFF"
        ])
        writer.writerow([])
        
        # Summary Totals
        writer.writerow(["SUMMARY TOTALS"])
        writer.writerow(["Metric", "Bill A", "Bill B", "Status"])
        for field in ['subtotal', 'vat', 'total']:
            diff_data = differences[field]
            writer.writerow([
                field.upper(),
                diff_data['a'] or "—",
                diff_data['b'] or "—", 
                "OK" if diff_data['equal'] else "DIFF"
            ])
        writer.writerow([])
        
        # Line Items
        writer.writerow(["LINE ITEMS"])
        writer.writerow(["Category & Description", "Example", "Amount A", "Amount B", "Delta", "Status"])
        if 'items' in differences:
            items_data = differences['items']
            for key, item in items_data.items():
                writer.writerow([
                    key,
                    item.get('example_a') or item.get('example_b') or "—",
                    item.get('a_amount') or "—",
                    item.get('b_amount') or "—",
                    item.get('delta') or "—",
                    item.get('status', 'UNKNOWN')
                ])
        else:
            writer.writerow(["No line items found", "", "", "", "", ""])
        writer.writerow([])
        
        # VAT Summary
        if 'vat_summary' in differences and differences['vat_summary']:
            writer.writerow(["VAT SUMMARY"])
            writer.writerow(["Item", "Bill A", "Bill B", "Status"])
            for key, vat_item in differences['vat_summary'].items():
                writer.writerow([
                    key,
                    vat_item.get('a') or "—",
                    vat_item.get('b') or "—",
                    "OK" if vat_item.get('equal') else "DIFF"
                ])
    
    logger.info(f"Generated CSV report: {output_path}")


import json

def generate_json_report(bill_a: ParsedBill, bill_b: ParsedBill, 
                        differences: Dict[str, Any], output_path: str) -> None:
    """Generate JSON comparison report without separate totals section"""
    
    report_data = {
        "metadata": {
            "generated": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "file_a": bill_a.file,
            "file_b": bill_b.file,
            "match_score": differences.get('match_score', 0)
        },
        "account_comparison": {
            "account_a": bill_a.account,
            "account_b": bill_b.account,
            "equal": differences['account']['equal'],
            "status": "OK" if differences['account']['equal'] else "DIFF"
        },
        "address_comparison": {
            "address_a": bill_a.billing_address,
            "address_b": bill_b.billing_address,
            "similarity": differences['address']['similarity'],
            "equal": differences['address']['equal'],
            "status": "OK" if differences['address']['equal'] else "DIFF"
        },
        "line_items": differences.get('items', {}),
        # We're removing the separate totals_comparison section
        # since the data is not being extracted properly
    }
    
    # Only include VAT summary if we have data
    if differences.get('vat_summary'):
        report_data["vat_summary"] = differences['vat_summary']
    
    # Write JSON file
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(report_data, f, indent=2, ensure_ascii=False)
    
    logger.info(f"Generated JSON report: {output_path}")


def json_to_html_report(json_file_path: str, output_html_path: str) -> None:
    """Convert JSON report to beautiful HTML for client presentation"""
    
    try:
        with open(json_file_path, 'r', encoding='utf-8') as f:
            report_data = json.load(f)
        
        html_content = generate_html_from_json(report_data)
        
        with open(output_html_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        logger.info(f"Converted JSON to HTML: {output_html_path}")
        
    except Exception as e:
        logger.error(f"Failed to convert JSON to HTML: {e}")
        raise

def generate_html_from_json(report_data: Dict) -> str:
    """Generate professional HTML from JSON report data without separate totals section"""
    
    metadata = report_data.get('metadata', {})
    account_comp = report_data.get('account_comparison', {})
    address_comp = report_data.get('address_comparison', {})
    totals_comp = report_data.get('totals_comparison', {})
    line_items = report_data.get('line_items', {})
    vat_summary = report_data.get('vat_summary', {})
    
    # Calculate color-coded score
    match_score = metadata.get('match_score', 0)
    if match_score >= 90:
        score_class = "score-high"
        score_icon = "✅"
    elif match_score >= 70:
        score_class = "score-medium" 
        score_icon = "⚠️"
    else:
        score_class = "score-low"
        score_icon = "❌"
    
    # Prepare line items including VAT and Total if available
    all_line_items = dict(line_items)  # Start with regular line items
    
    # Add VAT as a special line item if available
    vat_amount_a = totals_comp.get('vat', {}).get('amount_a')
    vat_amount_b = totals_comp.get('vat', {}).get('amount_b')
    if vat_amount_a or vat_amount_b:
        all_line_items["vat_summary||vat_amount"] = {
            "a_amount": vat_amount_a,
            "b_amount": vat_amount_b,
            "equal": totals_comp.get('vat', {}).get('equal', False),
            "delta": calculate_delta(vat_amount_a, vat_amount_b),
            "status": "OK" if totals_comp.get('vat', {}).get('equal', False) else "DIFF",
            "example_a": "VAT Amount",
            "example_b": "VAT Amount"
        }
    
    # Add Total as a special line item if available
    total_amount_a = totals_comp.get('total', {}).get('amount_a')
    total_amount_b = totals_comp.get('total', {}).get('amount_b')
    if total_amount_a or total_amount_b:
        all_line_items["overview||total_amount"] = {
            "a_amount": total_amount_a,
            "b_amount": total_amount_b,
            "equal": totals_comp.get('total', {}).get('equal', False),
            "delta": calculate_delta(total_amount_a, total_amount_b),
            "status": "OK" if totals_comp.get('total', {}).get('equal', False) else "DIFF",
            "example_a": "Total Amount",
            "example_b": "Total Amount"
        }
    
    html = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>BT Bill Comparison - {metadata.get('file_a', '')} vs {metadata.get('file_b', '')}</title>
        <style>
            * {{ box-sizing: border-box; margin: 0; padding: 0; }}
            body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; background: #f8f9fa; margin: 0; padding: 20px; }}
            .container {{ max-width: 1400px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
            h1 {{ color: #0047ab; margin-bottom: 10px; border-bottom: 2px solid #0047ab; padding-bottom: 10px; }}
            h2 {{ color: #0056b3; margin: 25px 0 15px 0; padding-bottom: 8px; border-bottom: 1px solid #e0e0e0; }}
            .header-info {{ background: #e8f4ff; padding: 15px; border-radius: 6px; margin-bottom: 20px; }}
            .score {{ display: inline-block; padding: 8px 16px; border-radius: 20px; font-weight: bold; margin: 10px 0; }}
            .score-high {{ background: #d4edda; color: #155724; }}
            .score-medium {{ background: #fff3cd; color: #856404; }}
            .score-low {{ background: #f8d7da; color: #721c24; }}
            table {{ width: 100%; border-collapse: collapse; margin: 15px 0; background: white; }}
            th, td {{ padding: 12px 15px; text-align: left; border: 1px solid #dee2e6; }}
            th {{ background: #0047ab; color: white; font-weight: 600; }}
            tr:nth-child(even) {{ background: #f8f9fa; }}
            .status-ok {{ background: #d4edda; color: #155724; padding: 4px 8px; border-radius: 4px; font-weight: bold; }}
            .status-diff {{ background: #f8d7da; color: #721c24; padding: 4px 8px; border-radius: 4px; font-weight: bold; }}
            .status-missing {{ background: #fff3cd; color: #856404; padding: 4px 8px; border-radius: 4px; font-weight: bold; }}
            .delta-positive {{ color: #dc3545; font-weight: bold; }}
            .delta-negative {{ color: #28a745; font-weight: bold; }}
            .section {{ margin-bottom: 30px; }}
            .timestamp {{ color: #6c757d; font-size: 0.9em; margin-bottom: 20px; }}
            .file-info {{ display: flex; justify-content: space-between; flex-wrap: wrap; gap: 20px; margin: 15px 0; }}
            .file-card {{ flex: 1; min-width: 300px; background: #f8f9fa; padding: 15px; border-radius: 6px; border-left: 4px solid #0047ab; }}
            .summary-card {{ background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 10px 0; }}
            .address-block {{ background: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; white-space: pre-wrap; }}
            .total-row {{ background: #e8f4ff !important; font-weight: bold; border-top: 2px solid #0047ab; }}
            .vat-row {{ background: #f0f8ff !important; font-weight: 600; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>📊 BT Bill Comparison Report</h1>
            <div class="timestamp">Generated: {metadata.get('generated', 'Unknown')}</div>
            
            <div class="header-info">
                <div class="file-info">
                    <div class="file-card">
                        <strong>📄 File A:</strong> {metadata.get('file_a', 'Unknown')}<br>
                        <strong>👤 Account:</strong> {account_comp.get('account_a', 'Not found')}<br>
                    </div>
                    <div class="file-card">
                        <strong>📄 File B:</strong> {metadata.get('file_b', 'Unknown')}<br>
                        <strong>👤 Account:</strong> {account_comp.get('account_b', 'Not found')}<br>
                    </div>
                </div>
                
                <div class="summary-card">
                    <strong>Overall Match Score: </strong>
                    <span class="score {score_class}">{score_icon} {match_score}%</span>
                    <div style="margin-top: 8px; font-size: 0.9em;">
                        {get_score_interpretation(match_score)}
                    </div>
                </div>
            </div>

            <!-- Account & Address Comparison -->
            <div class="section">
                <h2>👤 Account & Billing Address</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Field</th>
                            <th>Bill A</th>
                            <th>Bill B</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Account Number</strong></td>
                            <td>{account_comp.get('account_a', '—')}</td>
                            <td>{account_comp.get('account_b', '—')}</td>
                            <td>
                                <span class="{'status-ok' if account_comp.get('equal') else 'status-diff'}">
                                    {'✅ OK' if account_comp.get('equal') else '❌ DIFF'}
                                </span>
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Billing Address</strong></td>
                            <td><div class="address-block">{format_address(address_comp.get('address_a', '—'))}</div></td>
                            <td><div class="address-block">{format_address(address_comp.get('address_b', '—'))}</div></td>
                            <td>
                                <span class="{'status-ok' if address_comp.get('equal') else 'status-diff'}">
                                    {'✅ OK' if address_comp.get('equal') else f'❌ DIFF ({address_comp.get("similarity", 0)}% similar)'}
                                </span>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Combined Line Items, VAT and Total -->
            <div class="section">
                <h2>📋 Line Item Comparison (Including VAT & Total)</h2>
    """
    
    if all_line_items:
        html += """
                <table>
                    <thead>
                        <tr>
                            <th>Category & Description</th>
                            <th>Bill A Amount</th>
                            <th>Bill B Amount</th>
                            <th>Delta (B - A)</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
        """
        
        # Sort items to show totals at the bottom
        sorted_items = sorted(all_line_items.items(), 
                            key=lambda x: ('total' in x[0].lower() or 'vat' in x[0].lower(), x[0]))
        
        for item_key, item_data in sorted_items:
            # Determine row class for styling
            row_class = ""
            if 'total' in item_key.lower():
                row_class = "total-row"
            elif 'vat' in item_key.lower():
                row_class = "vat-row"
            
            status_class = "status-ok" if item_data.get('equal') else "status-diff"
            status_icon = "✅" if item_data.get('equal') else "❌"
            status_text = "OK" if item_data.get('equal') else item_data.get('status', 'DIFF')
            
            delta = item_data.get('delta')
            delta_html = "—"
            if delta and delta != 'None':
                if delta.startswith('-'):
                    delta_html = f'<span class="delta-negative">{delta}</span>'
                else:
                    delta_html = f'<span class="delta-positive">+{delta}</span>'
            
            # Format amounts with £ symbol
            amount_a = item_data.get('a_amount', '—')
            amount_b = item_data.get('b_amount', '—')
            formatted_a = f"£{amount_a}" if amount_a and amount_a != '—' and amount_a != 'None' else '—'
            formatted_b = f"£{amount_b}" if amount_b and amount_b != '—' and amount_b != 'None' else '—'
            
            html += f"""
                        <tr class="{row_class}">
                            <td><strong>{item_key}</strong><br>
                                <small style="color: #666;">{item_data.get('example_a') or item_data.get('example_b') or ''}</small>
                            </td>
                            <td>{formatted_a}</td>
                            <td>{formatted_b}</td>
                            <td>{delta_html}</td>
                            <td><span class="{status_class}">{status_icon} {status_text}</span></td>
                        </tr>
            """
        
        html += """
                    </tbody>
                </table>
        """
    else:
        html += '<div class="summary-card">No line items found for comparison</div>'
    
    html += """
            </div>
        </div>
    </body>
    </html>
    """
    
    return html


def calculate_delta(amount_a: Optional[str], amount_b: Optional[str]) -> Optional[str]:
    """Calculate delta between two amounts"""
    if not amount_a or not amount_b or amount_a == 'None' or amount_b == 'None':
        return None
    
    try:
        delta = Decimal(amount_b) - Decimal(amount_a)
        return str(delta.quantize(Decimal("0.01")))
    except (InvalidOperation, ValueError):
        return None

def get_score_interpretation(score: float) -> str:
    """Get human-readable interpretation of match score"""
    if score >= 95:
        return "Excellent match - bills are nearly identical"
    elif score >= 85:
        return "Good match - minor differences detected"
    elif score >= 70:
        return "Fair match - some significant differences"
    elif score >= 50:
        return "Poor match - major differences detected"
    else:
        return "Very poor match - bills are substantially different"

def format_address(address: str) -> str:
    """Format address for better display"""
    if not address or address == 'None':
        return "Not found"
    # Replace pipe separators with line breaks
    return address.replace(' | ', '\n')


# ----------------------------
# Batch Processing
# ----------------------------
def process_batch_comparison(dir_a: str, dir_b: str, output_dir: str, 
                           specific_files: Optional[List[str]] = None,
                           report_format: str = "json") -> None:
    """Process batch comparison with configurable report format"""
    
    os.makedirs(output_dir, exist_ok=True)
    pdf_files_a = [f for f in os.listdir(dir_a) if f.lower().endswith('.pdf')]
    pdf_files_b_set = set([f for f in os.listdir(dir_b) if f.lower().endswith('.pdf')])
    
    if specific_files:
        pdf_files_a = [f for f in pdf_files_a if f in specific_files]
    
    index_entries = []
    
    for pdf_file in pdf_files_a:
        if pdf_file not in pdf_files_b_set:
            logger.warning(f"Skipping {pdf_file}: not found in directory B")
            continue
        
        try:
            logger.info(f"Processing: {pdf_file}")
            
            bill_a_path = os.path.join(dir_a, pdf_file)
            bill_b_path = os.path.join(dir_b, pdf_file)
            
            bill_a = parse_pdf_bill(bill_a_path)
            bill_b = parse_pdf_bill(bill_b_path)
            differences = compare_bills(bill_a, bill_b)
            
            # Generate report based on format
            base_name = os.path.splitext(pdf_file)[0]
            
            if report_format == "text":
                report_name = f"{base_name}_comparison.txt"
                report_path = os.path.join(output_dir, report_name)
                generate_text_report(bill_a, bill_b, differences, report_path)
            elif report_format == "csv":
                report_name = f"{base_name}_comparison.csv"
                report_path = os.path.join(output_dir, report_name)
                generate_csv_report(bill_a, bill_b, differences, report_path)
            else:  # Default to JSON
                report_name = f"{base_name}_comparison.json"
                report_path = os.path.join(output_dir, report_name)
                generate_json_report(bill_a, bill_b, differences, report_path)
            
            index_entries.append({
                'file': pdf_file,
                'report': report_name,
                'score': differences['match_score']
            })
            
        except Exception as e:
            logger.error(f"Failed to process {pdf_file}: {e}")
            continue
    
    # FIXED: Pass the report_format parameter
    generate_index_page(index_entries, output_dir, report_format)


def generate_index_page(entries: List[Dict], output_dir: str, report_format: str = "json") -> None:
    """Generate index page with links to all comparison reports"""
    index_path = os.path.join(output_dir, 'index.html')
    
    entries_sorted = sorted(entries, key=lambda x: x['score'], reverse=True)
    
    # Determine file extension based on format
    file_ext = {
        'json': '.json',
        'text': '.txt', 
        'csv': '.csv'
    }.get(report_format, '.json')
    
    html_content = f"""
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>BT Bill Comparison Index</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }}
            .container {{ max-width: 1000px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
            h1 {{ color: #0047ab; margin-bottom: 20px; }}
            table {{ width: 100%; border-collapse: collapse; margin-top: 20px; }}
            th, td {{ padding: 12px 15px; text-align: left; border-bottom: 1px solid #ddd; }}
            th {{ background: #0047ab; color: white; }}
            tr:hover {{ background: #f5f5f5; }}
            .score-high {{ color: #28a745; font-weight: bold; }}
            .score-medium {{ color: #ffc107; font-weight: bold; }}
            .score-low {{ color: #dc3545; font-weight: bold; }}
            .timestamp {{ color: #666; margin-bottom: 20px; }}
            .format-badge {{ background: #6c757d; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; margin-left: 10px; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>BT Bill Comparison Reports</h1>
            <div class="timestamp">Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</div>
            <p>Total reports: {len(entries)} <span class="format-badge">Format: {report_format.upper()}</span></p>
            
            <table>
                <thead>
                    <tr>
                        <th>PDF File</th>
                        <th>Comparison Report</th>
                        <th>Match Score</th>
                    </tr>
                </thead>
                <tbody>
    """
    
    for entry in entries_sorted:
        score_class = "score-high" if entry['score'] >= 90 else "score-medium" if entry['score'] >= 70 else "score-low"
        html_content += f"""
                    <tr>
                        <td>{entry['file']}</td>
                        <td><a href="{entry['report']}">{entry['report']}</a></td>
                        <td class="{score_class}">{entry['score']}%</td>
                    </tr>
        """
    
    html_content += """
                </tbody>
            </table>
        </div>
    </body>
    </html>
    """
    
    with open(index_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    logger.info(f"Generated index page: {index_path}")

# ----------------------------
# Command Line Interface
# ----------------------------
def convert_existing_json_to_html(json_dir: str) -> None:
    """Convert all existing JSON reports in directory to HTML"""
    json_files = [f for f in os.listdir(json_dir) if f.endswith('.json')]
    
    if not json_files:
        logger.warning(f"No JSON files found in {json_dir}")
        return
    
    for json_file in json_files:
        json_path = os.path.join(json_dir, json_file)
        html_file = json_file.replace('.json', '.html')
        html_path = os.path.join(json_dir, html_file)
        
        try:
            json_to_html_report(json_path, html_path)
            logger.info(f"Converted {json_file} to {html_file}")
        except Exception as e:
            logger.error(f"Failed to convert {json_file}: {e}")

# Update main function to handle this new argument
def main():
    parser = argparse.ArgumentParser(
        description='BT Bill Comparison Tool - Production Version',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('--dirA', help='Directory containing original PDF bills')
    parser.add_argument('--dirB', help='Directory containing new PDF bills for comparison')
    parser.add_argument('--out', help='Output directory for reports')
    parser.add_argument('--files', nargs='*', help='Specific PDF files to compare (optional)')
    parser.add_argument('--format', choices=['json', 'text', 'csv'], default='json', 
                       help='Output format for reports (default: json)')
    parser.add_argument('--convert-to-html', action='store_true', 
                       help='Convert JSON reports to HTML after generation')
    parser.add_argument('--convert-existing-json', metavar='DIRECTORY',
                       help='Convert existing JSON reports in directory to HTML')
    parser.add_argument('--debug', action='store_true', help='Enable debug logging')
    
    args = parser.parse_args()
    
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Handle conversion of existing JSON files
    if args.convert_existing_json:
        convert_existing_json_to_html(args.convert_existing_json)
        return
    
    # Validate required arguments for normal operation
    if not args.dirA or not args.dirB or not args.out:
        parser.error("--dirA, --dirB, and --out are required for bill comparison")
    
    # Process comparisons
    process_batch_comparison(args.dirA, args.dirB, args.out, args.files, args.format)
    
    # Convert JSON to HTML if requested
    if args.convert_to_html and args.format == 'json':
        convert_existing_json_to_html(args.out)

def convert_all_json_to_html(output_dir: str):
    """Convert all JSON reports in directory to HTML"""
    json_files = [f for f in os.listdir(output_dir) if f.endswith('.json')]
    
    for json_file in json_files:
        json_path = os.path.join(output_dir, json_file)
        html_file = json_file.replace('.json', '.html')
        html_path = os.path.join(output_dir, html_file)
        
        try:
            json_to_html_report(json_path, html_path)
            logger.info(f"Converted {json_file} to {html_file}")
        except Exception as e:
            logger.error(f"Failed to convert {json_file}: {e}")

if __name__ == '__main__':
    main()
